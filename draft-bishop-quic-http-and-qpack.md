---
title: Header Compression for HTTP/QUIC
abbrev: QPACK
docname: draft-bishop-quic-http-and-qpack-latest
date: {DATE}
category: std

ipr: trust200902
area: Transport
workgroup: QUIC Working Group
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: M. Bishop
    name: Mike Bishop
    organization: Microsoft
    email: michael.bishop@microsoft.com

normative:
  RFC7230:
  RFC7231:
  RFC7540:
  RFC2119:
  RFC7541:
  I-D.ietf-quic-transport:
  I-D.ietf-quic-http:


--- abstract

HTTP/2 [RFC7540] uses HPACK [RFC7541] for header compression. However, HPACK
relies on the in-order message-based semantics of the HTTP/2 framing layer in
order to function.  Messages can only be successfully decoded if processed by
the decoder in the same order as generated by the encoder.  This draft refines
HPACK to loosen the ordering requirements for use over QUIC
[I-D.ietf-quic-transport].

--- middle

# Introduction  {#problems}

HPACK has a number of features that were intended to provide performance
advantages to HTTP/2, but which don't live well in an out-of-order environment
such as that provided by QUIC.

The largest challenge is the fact that elements are referenced by a very fluid
index. Not only is the index implicit when an item is added to the header
table, the index will change without notice as other items are added to the
header table. Static entries occupy the first 61 values, followed by dynamic
entries. A newly-added dynamic entry would cause older dynamic entries to be
evicted, and the retained items are then renumbered beginning with 62. This
means that, without processing all preceding header sets, no index into the
dynamic table can be interpreted, and the index of a given entry cannot be
predicted.

Any solution to the above will almost certainly fall afoul of the memory
constraints the decompressor imposes. The automatic eviction of entries is done
based on the compressor's declared dynamic table size, which MUST be less than
the maximum permitted by the decompressor (and relayed using an HTTP/2 SETTINGS
value).

Further, streams in QUIC are lossy in the presence of stream resets.  While
HTTP/2 (via TCP) guarantees the delivery of all previously-sent data on a stream
even if that stream is reset, QUIC does not retransmit lost frames if a stream
has been reset, and may discard data which has not yet been delivered to the
application.

Previous versions of QPACK were small deltas of HPACK to introduce
order-resiliency. This version departs from HPACK more substantially to add
resilience against reset message streams.

In the following sections, this document proposes a new version of HPACK which
makes different trade-offs, enabling partial out-of-order interpretation and
bounded memory consumption with minimal head-of-line blocking. None of the
proposed improvements to HPACK (strongly-typed fields, binary compression of
common header syntax) are currently included, but certainly could be.

## Terminology          {#Terminology}
In this document, the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" are to be
interpreted as described in BCP 14, RFC 2119 {{RFC2119}} and indicate
requirement levels for compliant STuPiD implementations.

# QPACK {#QPACK}

## Basic model

HPACK combines header table modification and message header emission in a single
sequence of coded bytes.  QPACK bifurcates these into two channels:

  - A connection-wide series of table update instructions sent on a dedicated
    headers stream
  - Non-modifying instructions which use the current header table state to
    encode message headers

Because the per-message instructions introduce no changes to the header table
state, no state is lost if these instructions are discarded due to a stream
reset.

## Changes to Static and Dynamic Tables

QPACK uses two tables for associating header fields to indexes. The static
table is unchanged from [RFC7541].

The dynamic table is a map from index to header field. Indices are arbitrary
numbers greater than the last index of the static table and less than 2^27. Each
insert instruction will specify the index being modified. While any index MAY be
chosen for a new entry, smaller numbers will yield better compression
performance.

The dynamic table is still constrained to the size specified by the decoder. An
attempt to add a header to the dynamic table which causes it to exceed the
maximum size MUST be treated as an error by a decoder.  To enable encoders to
reclaim space, encoders can delete entries in the dynamic table, but can only
reuse the index or the space after receiving confirmation of a successful
deletion.

Because it is possible for QPACK frames to arrive which reference indices which
have not yet been defined, such frames MUST wait until another frame has
arrived and defined the index. In order to guard against malicious peers,
implementations SHOULD impose a time limit and treat expiration of the timer as
a decoding error. However, if the implementation chooses not to abort the
connection, the remainder of the header block MUST be decoded and the output
discarded.

### Dynamic Table State Synchronization

In order to ensure table consistency, all modifications of the header table
occur on a dedicated control stream.  Message control streams contain only
indexed and literal header entries.

No entries are automatically evicted from the dynamic table. Size management is
purely the responsibility of the encoder, which MUST NOT exceed the declared
memory size of the decoder.

The encoder SHOULD track the following information about each entry in the
table:

  - The list of recently-active streams which reference the entry in a trailer
    block, if any
  - The list of recently-active streams which reference the entry in a
    non-trailer block, if any

"Recently-active" streams are those which are still open or were closed less
than a reasonable number of RTTs ago.  An implementation MAY vary its definition
of "recent" to trade off memory consumption and timely completion of deletes.

The encoder MUST consider memory as committed beginning when the indexed entry
is assigned.

When the encoder wishes to delete an inserted value, it flows through the
following set of states:

  1. **Delete requested.**  The encoder emits a delete instruction indicating
     which streams might have referenced the entry.  The encoder MUST NOT
     reference the entry in any subsequent frame until this state machine has
     completed and MUST continue to include the entry in its calculation of
     consumed memory.

  2. **Delete pending.**  The decoder receives the delete instruction and
     checks the current state of its incoming streams (see
     {{delete-validation}}).  If more references might arrive, it stores the
     streams still needed and waits for them to complete.

  3. **Delete acknowledged.**  The decoder has received all QPACK frames which
     reference the deleted value, and can safely delete the entry.  The decoder
     SHOULD promptly emit a Delete-Ack instruction on the header management
     stream.

  4. **Delete completed.**  When the encoder receives a Delete-Ack instruction
     acknowledging the delete, it no longer counts the size of the deleted entry
     against the table size and MAY emit insert instructions for the field with
     a new value.

## Format of Header Management stream

The header management stream contains a series of QPACK instructions with no
message boundaries.  Data on this stream SHOULD be processed as soon as it
arrives.

This section describes the instructions which are possible on the Header
Management stream.

### Insert

An addition to the header table starts with the '1' one-bit pattern, followed
by the new index of the header represented as an integer with a 7-bit prefix.
This value is always greater than the number of entries in the static table.

If the header field name matches the header field name of an entry stored in the
static table or the dynamic table, the header field name can be represented
using the index of that entry. In this case, the index of the entry is
represented as an integer with an 8-bit prefix (see Section 5.1 of [RFC7231]).
This value is always non-zero.

~~~~~~~~~~
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 |       New Index (7+)      |
   +---+---+-----------------------+
   |          Name Index (8+)      |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
~~~~~~~~~~
{: title="Insert Header Field -- Indexed Name"}

Otherwise, the header field name is represented as a string literal (see Section
5.2 of [RFC7231]). A value 0 is used in place of the 8-bit index, followed by
the header field name.

~~~~~~~~~~
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 |       New Index (7+)      |
   +---+---+-----------------------+
   |               0               |
   +---+---+-----------------------+
   | H |     Name Length (7+)      |
   +---+---------------------------+
   |  Name String (Length octets)  |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
~~~~~~~~~~
{: title="Insert Header Field -- New Name"}

Either form of header field name representation is followed by the header field
value represented as a string literal (see Section 5.2 of [RFC7541]).

An encoder MUST NOT attempt to place a value at an index not known to be vacant.
A decoder MUST treat the attempt to insert into an occupied slot as a fatal
error.


### Delete

A deletion from the header table starts with the '00' two bit pattern, followed
by the index of the affected entry represented as an integer with a 6-bit prefix.
This value is always greater than the number of entries in the static table.

A delete instruction then encodes a series of stream IDs which might have
contained references to the entry in question.

~~~~~~~~~~
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 |      Index (6+)       |
   +---+---+-----------------------+
   |     Non-Trailer List (*)    ...
   +-------------------------------+
   |       Trailer List (*)      ...
   +-------------------------------+                  
~~~~~~~~~~
{: title="Delete Instruction"}

Both the Non-Trailer List and Trailer List are Stream ID Lists (see below)
encoding a list of streams which might have referenced the entry either in
non-trailer or trailer blocks.

#### Stream ID List

A Stream ID List encodes a sequence of stream IDs in two parts:  First, a
Horizon value indicates the first non-occurrence about which data is maintained.
If data is maintained from the beginning of the connection, the Horizon is zero.
This allows senders to succinctly express both old state which has been
discarded and large regions where many or all streams contain references.

Following the horizon, a sequence of deltas indicates all streams since the
Horizon on which a value has been used.

In the extreme case, a Stream ID List might be a horizon value followed by one
zero byte.  This indicates an absolute cut-off after which the entry is
guaranteed not to be referenced.

~~~~~~~~~~
     0   1   2   3   4   5   6   7
   +-------------------------------+
   |          Horizon (8+)         |
   +-------------------------------+
   |         NumEntries (8+)       |
   +-------------------------------+
   |         [Delta1 (8+)]         |
   +-------------------------------+
   |         [Delta2 (8+)]         |
   +-------------------------------+
                  ...
   +-------------------------------+
   |         [DeltaN (8+)]         |
   +-------------------------------+                  
~~~~~~~~~~
{: title="Stream ID List"}

The field are as follows:

Horizon:
: The ID of the first stream for which the sender retains state which does not
  reference the deleted entry in the indicated block

NumEntries:
: The number of streams greater than the Horizon which might reference the entry
  and are listed in the remainder of the instruction

Delta1..N:
: A sequence of streams greater than the Horizon which might reference the
  entry, encoded as the difference in stream number from the previously-listed
  stream.  This field is repeated NumEntries times.

#### Delete Validation {#delete-validation}

In order to safely delete an entry, a decoder MUST ensure that all outstanding
references have arrived and been processed.  Because no data is available about
stream IDs less than the Horizon, a decoder MUST assume that any earlier stream ID
might have contained a reference to the value in question.

A decoder can ensure all outstanding references have been processed by verifying
that the following statements are true:

- In the Non-Trailer Block, all streams less than the Horizon and all streams
  explicitly listed are in one of two states:
    - closed
    - headers completely processed
- In the Trailer Block, all streams less than the Horizon and all streams
  explicitly listed are in one of three states:
    - closed
    - headers completely processed AND no trailers are expected
    - trailers completely processed

An implementation MAY omit the "trailers completely processed" case, since the
stream is expected to close immediately after receipt of the trailers block.

If these conditions are not met upon receipt of a Delete instruction, a decoder
MUST wait to emit a Delete-Ack instruction until the outstanding streams have
reached an appropriate state.

### Delete-Ack {#delete-ack}

Confirmation that a delete has completed is expressed by an instruction which
starts with the '01' two-bit pattern, followed by the index of the affected
entry represented as an integer with a 6-bit prefix. This value is always
greater than the number of entries in the static table.

Note that unlike all other instructions, this instruction refers to the
receiver's dynamic table, not the sender's.

~~~~~~~~~~
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |      Index (6+)       |
   +---+---+-----------------------+
~~~~~~~~~~
{: title="Delete-Ack Instruction"}

This instruction MUST NOT be sent before the conditions described in
{{delete-validation}} have been satisfied, and SHOULD be sent as soon as
possible once they are.

## Format of Encoded Headers on Message Streams

Frames which carry HTTP message headers encode them using the following
instructions:

### Indexed Header Field Representation

An indexed header field representation identifies an entry in either the static
table or the dynamic table and causes that header field to be added to the
decoded header list, as described in Section 3.2 of [RFC7541].

~~~~~~~~~~
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
~~~~~~~~~~
{: title="Indexed Header Field"}

An indexed header field starts with the '1' 1-bit pattern, followed by the index
of the matching header field, represented as an integer with a 7-bit prefix (see
Section 5.1 of [RFC7541]).

The index value of 0 is not used.  It MUST be treated as a decoding error if
found in an indexed header field representation.

### Literal Header Field Representation

A literal header field representation starts with the '0' 1-bit pattern and
causes a header field to be added the decoded header list.

The second bit, 'N', indicates whether an intermediary may add this header to
the dynamic header table on subsequent hops. When the 'N' bit is set, the
encoded header MUST always be encoded with this specific literal representation.
In particular, when a peer sends a header field that it received represented as
a literal header field never indexed, it MUST use the same representation to
forward this header field.  This bit is intended for protecting header field
values that are not to be put at risk by compressing them (see Section 7.1 of
[RFC7541] for more details).

If the header field name matches the header field name of an entry stored in the
static table or the dynamic table, the header field name can be represented
using the index of that entry. In this case, the index of the entry is
represented as an integer with a 6-bit prefix (see Section 5.1 of [RFC7231]).
This value is always non-zero.

~~~~~~~~~~
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | N |    Name Index (6+)    |
   +---+---+-----------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
~~~~~~~~~~
{: title="Literal Header Field -- Indexed Name"}

Otherwise, the header field name is represented as a string literal (see Section
5.2 of [RFC7231]). A value 0 is used in place of the 6-bit index, followed by
the header field name.

~~~~~~~~~~
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | N |           0           |
   +---+---+-----------------------+
   | H |     Name Length (7+)      |
   +---+---------------------------+
   |  Name String (Length octets)  |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
~~~~~~~~~~
{: title="Literal Header Field -- Literal Name"}

Either form of header field name representation is followed by the header field
value represented as a string literal (see Section 5.2).

# Use in HTTP/QUIC

HTTP/QUIC [I-D.ietf-quic-http] currently retains the HPACK encoder/decoder from
HTTP/2, using a Sequence number to enforce ordering. Using QPACK instead would
entail the following changes:

- The Sequence field is removed from HEADERS frames (Section 5.2.2) and
  PUSH_PROMISE frames (Section 5.2.6).
- Header Block Fragments consist of QPACK data instead of HPACK data.
- An additional control stream is reserved for header table updates. Alternately,
  this could be carried by HEADERS frames on the connection control stream.

A HEADERS or PUSH_PROMISE frame MAY contain an arbitrary number of QPACK
instructions, but QPACK instructions SHOULD NOT cross a boundary between
successive HEADERS frames.  A partial HEADERS or PUSH_PROMISE frame MAY be
processed upon arrival and the resulting partial header set emitted or buffered
according to implementation requirements.

# Performance Considerations

While QPACK is designed to minimize head-of-line blocking between streams on
header decoding, there are some situations in which lost or delayed packets can
still impact the performance of header compression.

References to indexed entries will block if the frame containing the entry
definition is lost or delayed. Encoders MAY choose to trade off compression
efficiency and avoid blocking by using literal instructions rather than
referencing the dynamic table until the insertion is believed to be complete.

Since it is possible to insert header values without emitting them on a stream,
an encoder MAY proactively insert header values which it believes will be needed
on future requests.

Delayed frames which prevent deletes from completing can prevent the encoder
from adding any new entries due to the maximum table size. This does not block
the encoder from continuing to make requests, but could sharply limit
compression performance. Encoders would be well-served to delete entries in
advance of encountering the table maximum. Decoders SHOULD be prompt about
emitting Delete-Ack instructions to enable the encoder to recover the table
space.

# Security Considerations

The security considerations for QPACK are believed to be the same as for HPACK.

# IANA Considerations

This document currently makes no request of IANA, but probably should. In
particular, the QPACK-ACK frame needs to be registered and have a frame type
number assigned.

# Acknowledgements {#ack}

This draft draws heavily on the text of [RFC7541]. The indirect input of those
authors is gratefully acknowledged, as well as ideas gleefully stolen from:

  - Jana Iyengar
  - Patrick McManus
  - Martin Thomson
  - Charles 'Buck' Krasic
  - Kyle Rose

--- back
